import asyncio
import json
from typing import List, Literal

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.messages import TextMessage
from autogen_core import CancellationToken
from pydantic import BaseModel, ValidationError, field_validator

from DAY2.agents.worker_agent import WorkerAgent
from DAY2.agents.reflector_agent import ReflectorAgent
from DAY2.agents.validator import ValidatorAgent

def extract_json_object(text: str) -> str:
    start = text.find("{")
    if start == -1:
        raise ValueError("No JSON object found")

    depth = 0
    for i in range(start, len(text)):
        if text[i] == "{":
            depth += 1
        elif text[i] == "}":
            depth -= 1
            if depth == 0:
                return text[start:i + 1]

    raise ValueError("Unbalanced JSON braces")

planner_msg = """
"You are a planner.\n\n"
        "Your ONLY job is to output a JSON object describing a task DAG by breaking down user query into subtasks."
        "STRICT RULES:\n"
        "- Output ONLY valid JSON\n"
        "JSON SCHEMA:\n"
        "{\n"
        '  "nodes": [\n'
        "    {\n"
        '      "id": string,\n'
        '      "role": "worker" | "reflector" | "validator",\n'
        '      "task": string,\n'
        '      "deps": string[]\n'
        "    }\n"
        "  ]\n"
        "}\n\n"
        "The DAG MUST:\n"
        "- Contain at least one worker\n"
        "- Contain exactly one validator\n"
        "- End with a validator node\n\n"
        If you cannot generate a valid DAG, output:
        {
        "nodes": []
        }
        
        Expected Output: JSON OBJECT
"""

class DAGNode(BaseModel):
    id: str
    role: Literal["worker", "reflector", "validator"]
    task: str
    deps: List[str]

    @field_validator("id")
    @classmethod
    def id_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError("id must be non-empty")
        return v

class Planner:
    def __init__(self, model_client):
        self.model_client = model_client
        self.execution_tree = {}

        self.planner_agent = AssistantAgent(
            name="planner",
            system_message=(planner_msg),
            model_client=model_client,
        )

    def _validate_dag(self, nodes: List[DAGNode]) -> None:
        ids = {n.id for n in nodes}
        for node in nodes:
            for dep in node.deps:
                if dep not in ids:
                    raise ValueError(
                        f"Node '{node.id}' depends on unknown node '{dep}'"
                    )

        validators = [n for n in nodes if n.role == "validator"]
        if len(validators) != 1:
            raise ValueError("DAG must contain exactly one validator node")

        if not validators[0].deps:
            raise ValueError("Validator must have at least one dependency")

    async def create_plan(self, query: str) -> List[DAGNode]:
        cancellation = CancellationToken()
        response = await self.planner_agent.on_messages(
            [TextMessage(content=query, source="user")],
            cancellation
        )
        output = response.chat_message.content
        print(response)
        print()
        print(output)

        try:
            json_text = extract_json_object(output)
            raw = json.loads(json_text)

            if "nodes" not in raw:
                raise ValueError("Missing 'nodes' key")

            nodes = [DAGNode(**n) for n in raw["nodes"]]
            self._validate_dag(nodes)
            return nodes

        except (json.JSONDecodeError, KeyError, ValidationError, ValueError) as e:
            raise RuntimeError(f"Invalid DAG generated by planner: {e}")

    async def run(self, query: str):
        nodes = await self.create_plan(query)

        results = {}
        pending = {n.id: n for n in nodes}

        while pending:
            ready = [
                n for n in pending.values()
                if all(dep in results for dep in n.deps)
            ]

            if not ready:
                raise RuntimeError("Cyclic or invalid DAG")

            tasks = []
            for node in ready:
                if node.role == "worker":
                    agent = WorkerAgent(
                        name=node.id,
                        task=node.task,
                        model_client=self.model_client,
                    )
                    tasks.append(self._run_worker(agent, node, query))

                elif node.role == "reflector":
                    agent = ReflectorAgent(self.model_client)
                    inputs = [results[d] for d in node.deps]
                    tasks.append(self._run_reflector(agent, node, inputs))

                elif node.role == "validator":
                    agent = ValidatorAgent(self.model_client)
                    input_text = results[node.deps[0]]
                    tasks.append(self._run_validator(agent, node, input_text))

            outputs = await asyncio.gather(*tasks)
            
            for node_id, output in outputs:
                results[node_id] = output
                self.execution_tree[node_id] = {
                    "deps": pending[node_id].deps,
                    "output": output,
                }
                del pending[node_id]

        final_node_id = next(n.id for n in nodes if n.role == "reflector")
        return results[final_node_id], self.execution_tree

    async def _run_worker(self, agent, node: DAGNode, query: str):
        output = await agent.run(query)
        return node.id, output["output"]

    async def _run_reflector(self, agent, node: DAGNode, inputs: List[str]):
        output = await agent.run(inputs)
        return node.id, output

    async def _run_validator(self, agent, node: DAGNode, input_text: str):
        output = await agent.run(input_text)
        return node.id, output